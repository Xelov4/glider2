#!/usr/bin/env python3
"""
Test optimis√© de reconnaissance des cartes
Se concentre sur la qualit√© de d√©tection avec seuils stricts
"""

import time
import cv2
import numpy as np
from modules.screen_capture import ScreenCapture
from modules.image_analysis import ImageAnalyzer
import json
from datetime import datetime
import os

class OptimizedCardRecognitionTester:
    """Testeur optimis√© de reconnaissance de cartes"""
    
    def __init__(self):
        self.screen_capture = ScreenCapture()
        self.image_analyzer = ImageAnalyzer()
        self.test_duration = 300  # 5 minutes
        self.capture_interval = 5  # 5 secondes entre captures
        
        # Statistiques optimis√©es
        self.stats = {
            'total_captures': 0,
            'valid_hands': 0,  # Mains avec exactement 2 cartes
            'valid_flops': 0,  # Flops avec 3-5 cartes
            'hands_with_suits': 0,
            'flops_with_suits': 0,
            'best_detections': [],
            'errors': 0
        }
        
        # Cache pour √©viter les r√©p√©titions
        self.last_hand = []
        self.last_flop = []
        
    def run_optimized_test(self):
        """Lance le test optimis√©"""
        print("üéØ TEST OPTIMIS√â DE RECONNAISSANCE DE CARTES")
        print("=" * 60)
        print(f"‚è±Ô∏è  Dur√©e: {self.test_duration} secondes")
        print(f"üì∏ Intervalle: {self.capture_interval} secondes")
        print("üéØ Objectif: Qualit√© > Quantit√©")
        print("=" * 60)
        
        start_time = time.time()
        capture_count = 0
        
        try:
            while time.time() - start_time < self.test_duration:
                capture_count += 1
                current_time = datetime.now().strftime("%H:%M:%S")
                
                print(f"\nüì∏ CAPTURE #{capture_count} - {current_time}")
                print("-" * 40)
                
                # Capture et analyse optimis√©e
                self.capture_and_analyze_optimized(current_time)
                
                # Attente
                time.sleep(self.capture_interval)
                
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è  Test interrompu par l'utilisateur")
        
        # Statistiques finales
        self.display_optimized_stats()
        
    def capture_and_analyze_optimized(self, timestamp):
        """Capture et analyse optimis√©e"""
        try:
            # Capture des zones
            hand_img = self.screen_capture.capture_region('hand_area')
            flop_img = self.screen_capture.capture_region('community_cards')
            
            if hand_img is None or flop_img is None:
                print("   ‚ö†Ô∏è  Impossible de capturer les zones")
                self.stats['errors'] += 1
                return
            
            # Analyse optimis√©e de la main
            print("   üÉè ANALYSE MAIN JOUEUR:")
            hand_result = self.analyze_hand_optimized(hand_img)
            
            # Analyse optimis√©e du flop
            print("   üÉè ANALYSE FLOP:")
            flop_result = self.analyze_flop_optimized(flop_img)
            
            # Mise √† jour des statistiques
            self.update_optimized_stats(hand_result, flop_result, timestamp)
            
            # Affichage des r√©sultats
            self.display_optimized_results(hand_result, flop_result)
            
        except Exception as e:
            print(f"   ‚ùå Erreur: {e}")
            self.stats['errors'] += 1
    
    def analyze_hand_optimized(self, img):
        """Analyse optimis√©e de la main (2 cartes max)"""
        try:
            cards = self.image_analyzer.detect_cards(img)
            
            if not cards:
                print("      ‚ö†Ô∏è  Aucune carte d√©tect√©e")
                return {'valid': False, 'cards': [], 'with_suits': 0}
            
            # Filtrer pour ne garder que les 2 meilleures cartes
            if len(cards) > 2:
                print(f"      ‚ö†Ô∏è  {len(cards)} cartes d√©tect√©es, filtrage des 2 meilleures")
                # Trier par confiance (si disponible) ou prendre les 2 premi√®res
                cards = cards[:2]
            
            card_details = []
            cards_with_suits = 0
            
            for card in cards:
                card_str = f"{card.rank}{card.suit}"
                card_details.append(card_str)
                if card.suit != '?':
                    cards_with_suits += 1
            
            is_valid = len(cards) == 2
            print(f"      üìä {len(cards)} cartes: {card_details}")
            print(f"         Suits: {cards_with_suits}/{len(cards)}")
            print(f"         Validit√©: {'‚úÖ' if is_valid else '‚ùå'}")
            
            return {
                'valid': is_valid,
                'cards': card_details,
                'with_suits': cards_with_suits,
                'total': len(cards)
            }
            
        except Exception as e:
            print(f"      ‚ùå Erreur analyse main: {e}")
            return {'valid': False, 'cards': [], 'with_suits': 0}
    
    def analyze_flop_optimized(self, img):
        """Analyse optimis√©e du flop (3-5 cartes)"""
        try:
            cards = self.image_analyzer.detect_cards(img)
            
            if not cards:
                print("      ‚ö†Ô∏è  Aucune carte d√©tect√©e")
                return {'valid': False, 'cards': [], 'with_suits': 0}
            
            # Filtrer pour ne garder que les 3-5 meilleures cartes
            if len(cards) > 5:
                print(f"      ‚ö†Ô∏è  {len(cards)} cartes d√©tect√©es, filtrage des 5 meilleures")
                cards = cards[:5]
            elif len(cards) < 3:
                print(f"      ‚ö†Ô∏è  {len(cards)} cartes d√©tect√©es (minimum 3 attendu)")
            
            card_details = []
            cards_with_suits = 0
            
            for card in cards:
                card_str = f"{card.rank}{card.suit}"
                card_details.append(card_str)
                if card.suit != '?':
                    cards_with_suits += 1
            
            is_valid = 3 <= len(cards) <= 5
            print(f"      üìä {len(cards)} cartes: {card_details}")
            print(f"         Suits: {cards_with_suits}/{len(cards)}")
            print(f"         Validit√©: {'‚úÖ' if is_valid else '‚ùå'}")
            
            return {
                'valid': is_valid,
                'cards': card_details,
                'with_suits': cards_with_suits,
                'total': len(cards)
            }
            
        except Exception as e:
            print(f"      ‚ùå Erreur analyse flop: {e}")
            return {'valid': False, 'cards': [], 'with_suits': 0}
    
    def update_optimized_stats(self, hand_result, flop_result, timestamp):
        """Met √† jour les statistiques optimis√©es"""
        self.stats['total_captures'] += 1
        
        # Main
        if hand_result['valid']:
            self.stats['valid_hands'] += 1
            if hand_result['with_suits'] == hand_result['total']:
                self.stats['hands_with_suits'] += 1
            
            if hand_result['cards'] != self.last_hand:
                self.stats['best_detections'].append({
                    'time': timestamp,
                    'type': 'hand',
                    'cards': hand_result['cards'],
                    'with_suits': hand_result['with_suits']
                })
                self.last_hand = hand_result['cards']
        
        # Flop
        if flop_result['valid']:
            self.stats['valid_flops'] += 1
            if flop_result['with_suits'] == flop_result['total']:
                self.stats['flops_with_suits'] += 1
            
            if flop_result['cards'] != self.last_flop:
                self.stats['best_detections'].append({
                    'time': timestamp,
                    'type': 'flop',
                    'cards': flop_result['cards'],
                    'with_suits': flop_result['with_suits']
                })
                self.last_flop = flop_result['cards']
    
    def display_optimized_results(self, hand_result, flop_result):
        """Affiche les r√©sultats optimis√©s"""
        print(f"   üìä R√âSULTATS OPTIMIS√âS:")
        
        if hand_result['valid']:
            print(f"      ‚úÖ Main valide: {hand_result['cards']}")
        else:
            print(f"      ‚ùå Main invalide: {hand_result['cards']}")
        
        if flop_result['valid']:
            print(f"      ‚úÖ Flop valide: {flop_result['cards']}")
        else:
            print(f"      ‚ùå Flop invalide: {flop_result['cards']}")
    
    def display_optimized_stats(self):
        """Affiche les statistiques optimis√©es finales"""
        print("\n" + "=" * 60)
        print("üìä STATISTIQUES OPTIMIS√âES FINALES")
        print("=" * 60)
        
        total = self.stats['total_captures']
        if total == 0:
            print("‚ùå Aucune capture effectu√©e")
            return
        
        print(f"üì∏ Captures totales: {total}")
        print(f"‚úÖ Mains valides: {self.stats['valid_hands']} ({self.stats['valid_hands']/total*100:.1f}%)")
        print(f"‚úÖ Flops valides: {self.stats['valid_flops']} ({self.stats['valid_flops']/total*100:.1f}%)")
        print(f"üéØ Mains avec suits: {self.stats['hands_with_suits']} ({self.stats['hands_with_suits']/max(1,self.stats['valid_hands'])*100:.1f}%)")
        print(f"üéØ Flops avec suits: {self.stats['flops_with_suits']} ({self.stats['flops_with_suits']/max(1,self.stats['valid_flops'])*100:.1f}%)")
        print(f"‚ùå Erreurs: {self.stats['errors']} ({self.stats['errors']/total*100:.1f}%)")
        
        # Affichage des meilleures d√©tections
        if self.stats['best_detections']:
            print(f"\nüèÜ MEILLEURES D√âTECTIONS ({len(self.stats['best_detections'])}):")
            for detection in self.stats['best_detections'][-5:]:
                print(f"   {detection['time']} - {detection['type'].upper()}: {detection['cards']} (suits: {detection['with_suits']})")
        
        print("\nüéØ CONCLUSION:")
        if self.stats['valid_hands'] > 0 or self.stats['valid_flops'] > 0:
            print("‚úÖ Reconnaissance de cartes optimis√©e fonctionnelle")
            if self.stats['valid_hands']/total > 0.5 and self.stats['valid_flops']/total > 0.5:
                print("‚úÖ Qualit√© de d√©tection satisfaisante")
            else:
                print("‚ö†Ô∏è  Qualit√© de d√©tection √† am√©liorer")
        else:
            print("‚ö†Ô∏è  Aucune d√©tection valide - v√©rifiez la fen√™tre poker")
        
        print("‚úÖ Test termin√©")

def main():
    """Fonction principale"""
    print("üéØ TEST OPTIMIS√â DE RECONNAISSANCE DE CARTES")
    print("Ce test se concentre sur la qualit√© de d√©tection")
    print("Assurez-vous que votre fen√™tre poker est ouverte")
    print("Appuyez sur Ctrl+C pour arr√™ter le test")
    print()
    
    tester = OptimizedCardRecognitionTester()
    tester.run_optimized_test()

if __name__ == "__main__":
    main() 